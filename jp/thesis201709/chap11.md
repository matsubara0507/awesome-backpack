本論文の動機付けは，ある主要な前提に基づいている．
それは，コンパイラとビルドシステム/パッケージマネージャーの間の抽象化の障壁(`abstraction barriers`)は保持すべきだというモノである．
Go と Rust のような最近のコンパイラには全部入りのビルドシステムや，ソフトウェアのパッケージングを管理することが役割の Bazel や Gradle のようなセマンティックビルドシステムなどから，この前提を再検討する価値があるだろう．

従来は，コンパイラとパッケージマネージャー間の抽象化の障壁は，これらのコンポーネントのさまざまな実装を提供することができるため，かなり有益だった．
例えば，単一のビルドシステムで複数の異なるコンパイラ(gccとclangなど)を扱うことができたし，逆に，ユーザー定義のビルドシステムからコンパイラを呼び出すことができた．
また，ライブラリであれば言語本来のパッケージマネージャとLinuxディストリビューションのパッケージシステムの両方でパッケージ化することができたし，逆に，パッケージマネージャはライブラリが実際にどのように構築されるかに関係無く利用できたかもしれない．
今日のソフトウェアエコシステムでは，これらの抽象化の障壁が有効に活用されている！

しかしながら，これらの抽象化の障壁を使用しても適切に処理することができないユースケースが増えている．

- ビルドシステムはソースファイルをビルドする順番を知る必要がある．
  しかし，この情報の基となるのはソースファイルの `import/include` 宣言である．
  そのため，この情報をビルドシステム内にもう一度書くか，ビルドシステムが使用する依存関係グラフを計算するためにコンパイラを呼び出す必要がある．
  いずれにせよ，コンパイラはソースファイルからオブジェクトファイルへの変換を行うだけでなく，ファイルの依存関係をどのように出力するかを知っている必要がある(`gcc -M` のように)．
  おそらく Makefile のスタブを除いて，この情報の標準化された形式は無いだろう．
  
従って，このようなコンポーネントを全て行う単一のモノリシックツールにロールアップすることは魅力的である．
単一のツールで開発するのは簡単だし，ユーザーエクスペリエンスはより均等になるし，開発者がさまざまなコンポーネント間で明確なAPIを指定する必要が無くなるなど，メリットはたくさんある．

この制度(従来の方を指してる？)であるならば，Backpack'17 が存在理由などほとんど無い．
だったら Backpack'14 を使ってくれ！
You see this theme play out in systems conferences, where abstraction barriers are routinely broken for fun and performance.
